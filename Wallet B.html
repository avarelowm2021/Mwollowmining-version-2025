<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MWAL ‚Äî Wallet (OFFLINE ‚Ä¢ Coffre-fort ‚Ä¢ Import JSON obligatoire ‚Ä¢ Minage interne)</title>
<style>
:root{
  --bg:#070a08;--panel:#0d1510;--panel2:#0a100c;--ink:#bfffdc;--ink2:#6dffb3;--muted:#8bb99e;
  --line:rgba(109,255,179,.16);--ok:#6dffb3;--warn:#ffd34d;--bad:#ff5a6a;--shadow:0 10px 30px rgba(0,0,0,.45);
}
*{box-sizing:border-box}
body{margin:0;color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:
  radial-gradient(900px 500px at 10% 0%, rgba(109,255,179,.10), transparent 60%),
  radial-gradient(900px 500px at 90% 10%, rgba(255,211,77,.06), transparent 60%),
  var(--bg);}
.wrap{max-width:1220px;margin:18px auto;padding:0 14px}
header{display:flex;align-items:flex-start;justify-content:space-between;gap:12px;flex-wrap:wrap;margin-bottom:14px}
.brand{display:flex;align-items:center;gap:10px}
.logo{width:42px;height:42px;border-radius:14px;border:1px solid rgba(109,255,179,.25);
  background:linear-gradient(135deg, rgba(109,255,179,.16), rgba(255,211,77,.12));box-shadow:var(--shadow);position:relative;}
.logo:after{content:"";position:absolute;inset:10px;border-radius:12px;background:linear-gradient(135deg, rgba(109,255,179,.35), rgba(255,211,77,.18));}
h1{margin:0;font-size:18px;color:var(--ink2)}
.sub{margin-top:2px;color:var(--muted);font-size:12px;max-width:820px}
.pill{display:flex;gap:10px;align-items:center;flex-wrap:wrap;padding:8px 10px;border-radius:12px;background:rgba(13,21,16,.75);
  border:1px solid rgba(109,255,179,.18);box-shadow:0 6px 18px rgba(0,0,0,.28)}
.pill b{color:var(--ink2)}
.grid{display:grid;grid-template-columns:1.05fr .95fr;gap:12px}
@media(max-width:980px){.grid{grid-template-columns:1fr}}
.card{background:linear-gradient(180deg, rgba(13,21,16,.88), rgba(10,16,12,.88));
  border:1px solid rgba(109,255,179,.18);border-radius:18px;box-shadow:var(--shadow);overflow:hidden;}
.hd{padding:12px 14px;border-bottom:1px solid rgba(109,255,179,.12);display:flex;justify-content:space-between;align-items:center;gap:10px}
.hd h2{margin:0;font-size:14px;color:var(--ink2)}
.bd{padding:14px}
label{display:block;font-size:12px;color:var(--muted);margin:0 0 6px}
input,textarea{width:100%;border-radius:12px;padding:10px 10px;background:rgba(8,12,9,.75);
  border:1px solid rgba(109,255,179,.18);color:var(--ink);outline:none;}
textarea{min-height:88px;resize:vertical}
input:focus,textarea:focus{border-color:rgba(109,255,179,.35)}
.row{display:flex;gap:10px;flex-wrap:wrap}
.row>*{flex:1 1 220px}
.btns{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
button{border:none;padding:10px 12px;border-radius:12px;cursor:pointer;background:linear-gradient(180deg, rgba(16,32,23,.9), rgba(10,18,12,.9));
  border:1px solid rgba(109,255,179,.2);color:var(--ink2);box-shadow:0 6px 18px rgba(0,0,0,.35);transition:transform .06s ease;}
button:hover{background:linear-gradient(180deg, rgba(22,44,31,.95), rgba(10,18,12,.95))}
button:active{transform:translateY(1px)}
button.secondary{color:var(--ink)}
button.warn{border-color:rgba(255,211,77,.35);color:#ffe6a7}
button.bad{border-color:rgba(255,90,106,.35);color:#ffd0d6}
button:disabled{opacity:.45;cursor:not-allowed}
.stats{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.stat{background:rgba(8,12,9,.55);border:1px solid rgba(109,255,179,.14);border-radius:16px;padding:12px}
.stat .lbl{font-size:12px;color:var(--muted)}
.stat .val{font-size:18px;color:var(--ink2);margin:6px 0 3px;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;}
.status{margin-top:10px;padding:10px 12px;border-radius:14px;background:rgba(8,12,9,.5);border:1px solid rgba(109,255,179,.12);font-size:12px;color:var(--muted);white-space:pre-wrap}
.status.ok{color:var(--ok)}
.status.warn{color:var(--warn)}
.status.err{color:var(--bad)}
.sep{height:1px;background:rgba(109,255,179,.12);margin:12px 0}
.hint{background:rgba(109,255,179,.08);border:1px solid rgba(109,255,179,.12);padding:10px 12px;border-radius:14px;font-size:12px;color:var(--muted)}
.list{max-height:280px;overflow:auto;border:1px solid rgba(109,255,179,.12);border-radius:14px;padding:10px;background:rgba(8,12,9,.35)}
.item{padding:10px;border:1px solid rgba(109,255,179,.12);border-radius:14px;margin-bottom:10px;background:rgba(8,12,9,.35)}
.item:last-child{margin-bottom:0}
.progress{width:100%;height:12px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(109,255,179,.14);overflow:hidden}
.progress>div{height:100%;width:0%;background:linear-gradient(90deg, rgba(109,255,179,.6), rgba(255,211,77,.45))}
.tag{display:inline-block;padding:3px 8px;border-radius:999px;border:1px solid rgba(109,255,179,.18);background:rgba(8,12,9,.45);font-size:11px;color:var(--muted)}
.small{font-size:12px;color:var(--muted)}

/* ===== Modal assistant import ledger ===== */
.modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;padding:14px;z-index:9999;}
.modal{width:min(860px,100%);background:linear-gradient(180deg, rgba(13,21,16,.96), rgba(10,16,12,.96));
  border:1px solid rgba(109,255,179,.22);border-radius:18px;box-shadow:var(--shadow);overflow:hidden;}
.modal-hd{padding:12px 14px;border-bottom:1px solid rgba(109,255,179,.12);display:flex;justify-content:space-between;align-items:center;gap:10px}
.modal-hd h3{margin:0;font-size:14px;color:var(--ink2)}
.modal-bd{padding:14px}
.kv{display:grid;grid-template-columns:170px 1fr;gap:8px 12px;font-size:12px}
.kv .k{color:var(--muted)}
.kv .v{color:var(--ink)}
.pillbox{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
.pilltag{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid rgba(109,255,179,.18);background:rgba(8,12,9,.45);font-size:12px;color:var(--muted)}
.pilltag.ok{color:var(--ok);border-color:rgba(109,255,179,.25)}
.pilltag.warn{color:var(--warn);border-color:rgba(255,211,77,.35)}
.pilltag.err{color:var(--bad);border-color:rgba(255,90,106,.35)}
.radioRow{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
.radioRow label{display:flex;align-items:flex-start;gap:8px;cursor:pointer;background:rgba(8,12,9,.35);border:1px solid rgba(109,255,179,.12);padding:10px 12px;border-radius:14px;min-width:220px}
.radioRow input{width:auto;margin-top:3px}
.modal-ft{padding:12px 14px;border-top:1px solid rgba(109,255,179,.12);display:flex;justify-content:flex-end;gap:10px;flex-wrap:wrap}
pre.codebox{margin:10px 0 0;background:rgba(8,12,9,.45);border:1px solid rgba(109,255,179,.12);padding:10px;border-radius:14px;max-height:180px;overflow:auto;font-size:12px}
</style>
</head>
<body>
<div class="wrap">
<header>
  <div class="brand">
    <div class="logo"></div>
    <div>
      <h1>MWAL ‚Äî Wallet (OFFLINE) üîê Coffre-fort</h1>
      <div class="sub">
        Wallet ‚Äúparticulier‚Äù : r√©ception + envoi par preuve (minage interne). Ledger sign√© ECDSA + verrou anti-onglets + assistant import ledger.
      </div>
    </div>
  </div>
  <div class="pill small">
    <span>Adresse Wallet</span> <b class="mono" id="addrLbl">‚Äî</b>
    <button class="secondary" id="btnCopyAddr">üìã Copier adresse</button>
  </div>
</header>

<div class="grid">
  <div class="card">
    <div class="hd"><h2>üì• R√©ception</h2><span class="tag">import JSON obligatoire</span></div>
    <div class="bd">
      <div class="row">
        <div>
          <label>Cl√© MWAL</label>
          <textarea id="inKey" class="mono" placeholder="MWAL|TX=...|FROM=...|TO=MWAL-WALLET-XXXXXX|AMOUNT=..."></textarea>
        </div>
        <div>
          <label>Code chiffr√©</label>
          <textarea id="inCode" class="mono" placeholder="MWAL-AESGCM|IV|CIPHERTEXT"></textarea>
        </div>
      </div>

      <div class="row">
        <div style="flex:1 1 100%">
          <label>JSON de blocs (preuve) ‚Äî importer .json</label>
          <textarea id="inProof" class="mono" placeholder="Coller le JSON ou importer le fichier"></textarea>
          <input type="file" id="importProof" accept=".json" style="margin-top:8px"/>
          <div class="btns">
            <button id="btnCheck">üîç V√©rifier</button>
            <button id="btnAccept" class="warn" disabled>‚úÖ Recevoir</button>
            <button id="btnClear" class="secondary">üßπ Effacer</button>
          </div>
          <div class="status" id="inStatus">Pr√™t.</div>
        </div>
      </div>

      <div class="sep"></div>

      <div class="stats">
        <div class="stat"><div class="lbl">Solde</div><div class="val mono" id="balLbl">0.00000000</div><div class="lbl">MWAL</div></div>
        <div class="stat"><div class="lbl">R√©ceptions</div><div class="val mono" id="rxCountLbl">0</div><div class="lbl">TX</div></div>
      </div>

      <div class="sep"></div>
      <div class="hint">
        Conditions : TO = <b>ton adresse</b> + JSON valide (unit + 4s + hash) + code chiffr√© coh√©rent (proofHash).<br>
        Anti-replay : une TX re√ßue ne peut √™tre re-re√ßue.
      </div>
    </div>
  </div>

  <div class="card">
    <div class="hd"><h2>üì§ Envoi</h2><span class="tag">minage interne 4s/bloc</span></div>
    <div class="bd">
      <div class="row">
        <div>
          <label>Adresse destinataire (TO)</label>
          <input id="outTo" class="mono" placeholder="MWAL-WALLET-XXXXXX ou MWAL-POS-XXXXXX"/>
        </div>
        <div>
          <label>Montant (MWAL) ‚Äî multiple exact de l‚Äôunit√©</label>
          <input id="outAmt" type="number" min="0" step="0.00000001" placeholder="0.00050000"/>
          <div class="small mono" id="outInfo">‚Äî</div>
        </div>
      </div>

      <div class="row">
        <div>
          <label>FROM (alias)</label>
          <input id="outFrom" placeholder="ex: moi"/>
        </div>
        <div>
          <label>Libell√© (optionnel)</label>
          <input id="outLabel" placeholder="ex: remboursement"/>
        </div>
      </div>

      <div class="sep"></div>

      <label>Progression minage (bloc X / Y)</label>
      <div class="progress"><div id="mineBar"></div></div>
      <div class="small mono" style="margin-top:8px" id="mineTxt">0 / 0</div>
      <div class="btns">
        <button id="btnMineStart">‚ñ∂ D√©marrer minage</button>
        <button id="btnMinePause" class="secondary" disabled>‚è∏ Pause</button>
        <button id="btnMineResume" class="secondary" disabled>‚ñ∂ Reprendre</button>
        <button id="btnMineCancel" class="bad" disabled>‚úñ Annuler</button>
      </div>
      <div class="status" id="mineStatus">Pr√™t.</div>

      <div class="sep"></div>

      <div class="row">
        <div>
          <label>Cl√© MWAL (√† envoyer)</label>
          <textarea id="outKey" class="mono" readonly></textarea>
          <div class="btns"><button id="btnCopyOutKey" class="secondary" disabled>üìã Copier cl√©</button></div>
        </div>
        <div>
          <label>Code chiffr√© (√† envoyer)</label>
          <textarea id="outCode" class="mono" readonly></textarea>
          <div class="btns"><button id="btnCopyOutCode" class="secondary" disabled>üìã Copier code</button></div>
        </div>
      </div>

      <div class="row">
        <div style="flex:1 1 100%">
          <label>üì¶ JSON preuve (√† importer c√¥t√© receveur)</label>
          <textarea id="outProof" class="mono" readonly></textarea>
          <div class="btns">
            <button id="btnExportOutProof" class="warn" disabled>üì¶ Export JSON</button>
            <button id="btnCopyOutProof" class="secondary" disabled>üìã Copier JSON</button>
          </div>
        </div>
      </div>

      <div class="sep"></div>
      <div class="hint">
        L‚Äôenvoi fabrique une nouvelle preuve. Le receveur importe : cl√© + code + JSON.<br>
        Verrou anti-onglets : si un autre onglet est actif, l‚Äôenvoi est bloqu√© (lecture seule).
      </div>
    </div>
  </div>
</div>

<div class="card" style="margin-top:12px">
  <div class="hd"><h2>üìú Historique des r√©ceptions</h2><span class="tag">local</span></div>
  <div class="bd">
    <div class="row">
      <div class="stat"><div class="lbl">Adresse</div><div class="val mono" id="addr2Lbl">‚Äî</div><div class="lbl">unique sur cet appareil</div></div>
      <div class="stat"><div class="lbl">R√®gles</div><div class="val mono">unit + 4s + hash</div><div class="lbl">MWAL_MINING_V2</div></div>
    </div>
    <div class="sep"></div>
    <div class="list" id="hist"></div>
  </div>
</div>

<div class="card" style="margin-top:12px">
  <div class="hd"><h2>‚öôÔ∏è Param√®tres</h2><span class="tag">coffre-fort</span></div>
  <div class="bd">
    <label>Secret protocole (identique √©metteur/receveur)</label>
    <input id="secret" class="mono" value="MWAL_CORE_2025_V2_PROTOCOL"/>

    <div class="sep"></div>

    <label>Identit√© de signature (cl√© publique) ‚Äî <b>COFFRE-FORT</b></label>
    <input id="sigKeyId" class="mono" readonly value="(initialisation‚Ä¶)">
    <div class="small">Restauration/Fusion autoris√©es uniquement si le ledger est sign√© par <b>cette</b> cl√©.</div>
    <div class="btns" style="margin-top:8px">
      <button id="btnExportPubKey" class="secondary">üîì Export cl√© publique (.json)</button>
      <button id="btnRotateKeys" class="bad">üîÅ Rotation cl√©s (dangereux)</button>
    </div>

    <div class="sep"></div>

    <div class="btns">
      <button id="btnExportLedger" class="warn">üì¶ Export ledger wallet (sign√©)</button>
      <button id="btnImportLedger" class="warn">üì• Import ledger wallet</button>
      <button id="btnResetAll" class="bad">üß® Reset wallet</button>
    </div>
    <input type="file" id="importLedger" accept=".json" style="display:none">

    <div class="status" id="sysStatus">Pr√™t.</div>

    <div class="sep"></div>
    <label>Logs</label>
    <textarea id="logs" class="mono" readonly style="min-height:180px"></textarea>
  </div>
</div>

<!-- ===== Modal assistant import ledger ===== -->
<div class="modal-backdrop" id="ledgerModalBackdrop" role="dialog" aria-modal="true">
  <div class="modal">
    <div class="modal-hd">
      <h3>üì• Assistant d‚Äôimport Ledger (Wallet)</h3>
      <button class="secondary" id="btnCloseLedgerModal">‚úñ Fermer</button>
    </div>
    <div class="modal-bd">
      <div class="hint">
        Modes :
        <b>Restaurer</b> (√©crase tout), <b>Fusionner</b> (ajoute TX manquantes), <b>Lecture seule</b> (aucune √©criture).
        <br><b>COFFRE-FORT :</b> restaurer/fusionner exigent la <b>m√™me cl√© locale</b>.
        <br><b>Verrou anti-onglets :</b> si une autre instance est active, restauration/fusion sont d√©sactiv√©es ici.
      </div>

      <div class="sep"></div>

      <div class="kv mono" id="ledgerSummaryKv"></div>
      <div class="pillbox" id="ledgerPills"></div>

      <div class="sep"></div>

      <div class="radioRow">
        <label>
          <input type="radio" name="ledgerMode" value="restore" checked>
          <div>
            <div class="mono" style="color:var(--ink2)">Restaurer (overwrite)</div>
            <div class="small">Remplace l‚Äô√©tat local par le ledger import√©.</div>
          </div>
        </label>
        <label>
          <input type="radio" name="ledgerMode" value="merge">
          <div>
            <div class="mono" style="color:var(--ink2)">Fusion intelligente</div>
            <div class="small">Ajoute uniquement les TX absentes + met √† jour solde & anti-replay.</div>
          </div>
        </label>
        <label>
          <input type="radio" name="ledgerMode" value="readonly">
          <div>
            <div class="mono" style="color:var(--ink2)">Lecture seule</div>
            <div class="small">Affiche le ledger (audit) sans modifier le wallet.</div>
          </div>
        </label>
      </div>

      <div class="sep"></div>

      <label>Pr√©visualisation (lecture seule)</label>
      <pre class="codebox mono" id="ledgerPreview"></pre>

      <div class="status" id="ledgerModalStatus">Pr√™t.</div>
    </div>
    <div class="modal-ft">
      <button class="secondary" id="btnLedgerCancel">Annuler</button>
      <button class="warn" id="btnLedgerApply">‚úÖ Appliquer</button>
    </div>
  </div>
</div>

<script>
(() => {
"use strict";

/* ===================== COFFRE-FORT ===================== */
const LEDGER_SAFE_MODE = true; // üîê coffre-fort ON

/* ===================== Instance Lock (ANTI-ONGLETS MULTIPLES) ===================== */
const INSTANCE_ID = (crypto.randomUUID ? crypto.randomUUID() : ("inst-"+Math.random().toString(36).slice(2)));
const INSTANCE_LOCK_KEY = "MWAL_WALLET_ACTIVE_INSTANCE_LOCK_V1";
const INSTANCE_LOCK_TTL = 8000;     // 8s
const INSTANCE_HEARTBEAT_MS = 3000; // 3s
let instanceHasLock = false;
let instanceHeartbeatTimer = null;
let instanceReclaimTimer = null;

/* ===================== Protocols & constants ===================== */
const PROOF_PROTOCOL="MWAL_MINING_V2";
const TX_PAYLOAD_PROTOCOL="MWAL_TX_PAYLOAD_V2";
const UNIT_MWAL_STR="0.00000694444444444444";
const UNIT_MWAL=0.00000694444444444444;
const INTERVAL_MS=4000;

const STORE_KEY="mwal_wallet_offline_v3";
const WALLET_ADDR_KEY="mwal_wallet_addr_v3";

const LEDGER_PROTOCOL_V3="MWAL_WALLET_LEDGER_V3";
const LEDGER_PROTOCOL_V5="MWAL_WALLET_LEDGER_V5";

const SIGN_DB_NAME="mwal_wallet_keys_db";
const SIGN_DB_VER=1;
const SIGN_STORE="keys";
const SIGN_KEYPAIR_ID="mwal_wallet_signing_keypair_v1";

const $=(id)=>document.getElementById(id);
const logs=$("logs");
const enc=new TextEncoder();

/* ===================== UI helpers ===================== */
function log(msg){
  const t=new Date().toISOString().replace("T"," ").replace("Z","");
  logs.value=`[${t}] ${msg}\n`+logs.value;
}
function setStatus(el,msg,cls){
  el.textContent=msg;
  el.classList.remove("ok","warn","err");
  if(cls) el.classList.add(cls);
}
function round8(n){return Math.round((n+Number.EPSILON)*1e8)/1e8;}
function safeNum(x){const n=Number(x); return Number.isFinite(n)?n:0;}

/* ===================== Instance lock helpers ===================== */
function _readLock(){
  try{ return JSON.parse(localStorage.getItem(INSTANCE_LOCK_KEY)); }catch{ return null; }
}
function acquireInstanceLock(){
  const now = Date.now();
  const lock = _readLock();
  if(lock && lock.id !== INSTANCE_ID && (now - lock.ts) < INSTANCE_LOCK_TTL){
    return false;
  }
  localStorage.setItem(INSTANCE_LOCK_KEY, JSON.stringify({ id: INSTANCE_ID, ts: now }));
  return true;
}
function releaseInstanceLock(){
  try{
    const lock=_readLock();
    if(lock && lock.id === INSTANCE_ID) localStorage.removeItem(INSTANCE_LOCK_KEY);
  }catch{}
}
function startInstanceHeartbeat(){
  stopInstanceHeartbeat();
  instanceHeartbeatTimer = setInterval(()=>{
    if(!instanceHasLock) return;
    localStorage.setItem(INSTANCE_LOCK_KEY, JSON.stringify({ id: INSTANCE_ID, ts: Date.now() }));
  }, INSTANCE_HEARTBEAT_MS);
}
function stopInstanceHeartbeat(){
  if(instanceHeartbeatTimer){ clearInterval(instanceHeartbeatTimer); instanceHeartbeatTimer=null; }
}
function startReclaimLoop(){
  if(instanceReclaimTimer) clearInterval(instanceReclaimTimer);
  instanceReclaimTimer = setInterval(()=>{
    if(instanceHasLock) return;
    const ok = acquireInstanceLock();
    if(ok){
      instanceHasLock = true;
      startInstanceHeartbeat();
      log("üîí Instance lock RECLAIM id="+INSTANCE_ID);
      enforceInstanceLockUI();
    }
  }, 2000);
}
function enforceInstanceLockUI(){
  const disabled = !instanceHasLock;
  [
    "btnAccept",
    "btnMineStart","btnMinePause","btnMineResume","btnMineCancel",
    "btnLedgerApply","btnResetAll","btnRotateKeys"
  ].forEach(id=>{
    const el = document.getElementById(id);
    if(el) el.disabled = disabled;
  });

  if(disabled){
    setStatus($("sysStatus"),
      "üîí Une autre instance du wallet est active.\nCette instance est en lecture seule (anti-duplication d‚Äôonglets).",
      "warn"
    );
    setStatus($("mineStatus"), "üîí Lecture seule : minage bloqu√© (autre onglet actif).", "warn");
  }
}

/* ===================== IDs ===================== */
function getOrCreateAddr(){
  let id=localStorage.getItem(WALLET_ADDR_KEY);
  if(id && /^MWAL-WALLET-[A-Z0-9]{6,12}$/.test(id)) return id;
  const rnd=Math.random().toString(36).slice(2,10).toUpperCase();
  id="MWAL-WALLET-"+rnd;
  localStorage.setItem(WALLET_ADDR_KEY,id);
  return id;
}
function uid(prefix="TX"){
  return `${prefix}-${Date.now().toString(36).toUpperCase()}-${Math.random().toString(36).slice(2,8).toUpperCase()}`;
}

/* ===================== Crypto helpers ===================== */
async function sha256Hex(text){
  const buf=await crypto.subtle.digest("SHA-256", enc.encode(text));
  return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,"0")).join("");
}
function b64FromBytes(bytes){let s="";bytes.forEach(b=>s+=String.fromCharCode(b));return btoa(s);}
function bytesFromB64(b64){
  const s=atob(b64); const out=new Uint8Array(s.length);
  for(let i=0;i<s.length;i++) out[i]=s.charCodeAt(i);
  return out;
}
function b64FromArrayBuffer(buf){
  return btoa(String.fromCharCode(...new Uint8Array(buf)));
}
function arrayBufferFromB64(b64){
  const bin=atob(b64);
  const out=new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) out[i]=bin.charCodeAt(i);
  return out.buffer;
}
function stableStringify(value){
  const seen=new WeakSet();
  const helper=(v)=>{
    if(v===null || typeof v!=="object") return v;
    if(seen.has(v)) throw new Error("CYCLE");
    seen.add(v);
    if(Array.isArray(v)) return v.map(helper);
    const keys=Object.keys(v).sort();
    const out={};
    for(const k of keys) out[k]=helper(v[k]);
    return out;
  };
  return JSON.stringify(helper(value));
}

/* ===================== AES-GCM (TX payload) ===================== */
async function deriveAesKey(secret){
  const base=await crypto.subtle.importKey("raw", enc.encode(secret), {name:"PBKDF2"}, false, ["deriveKey"]);
  return crypto.subtle.deriveKey(
    {name:"PBKDF2",salt:enc.encode("MWAL_SALT_V2"),iterations:100000,hash:"SHA-256"},
    base,{name:"AES-GCM",length:256},false,["encrypt","decrypt"]
  );
}
async function decryptJson(secret,packed){
  const parts=String(packed||"").split("|");
  if(parts.length!==3 || parts[0]!=="MWAL-AESGCM") throw new Error("BAD_CODE");
  const iv=bytesFromB64(parts[1]);
  const ct=bytesFromB64(parts[2]);
  const key=await deriveAesKey(secret);
  const ptBuf=await crypto.subtle.decrypt({name:"AES-GCM",iv},key,ct);
  return JSON.parse(new TextDecoder().decode(ptBuf));
}
async function encryptJson(secret,obj){
  const key=await deriveAesKey(secret);
  const iv=crypto.getRandomValues(new Uint8Array(12));
  const plaintext=enc.encode(JSON.stringify(obj));
  const ct=new Uint8Array(await crypto.subtle.encrypt({name:"AES-GCM",iv},key,plaintext));
  return "MWAL-AESGCM|"+b64FromBytes(iv)+"|"+b64FromBytes(ct);
}

/* ===================== IndexedDB for CryptoKeyPair ===================== */
function openSignDb(){
  return new Promise((resolve,reject)=>{
    const req=indexedDB.open(SIGN_DB_NAME, SIGN_DB_VER);
    req.onupgradeneeded=()=>{
      const db=req.result;
      if(!db.objectStoreNames.contains(SIGN_STORE)) db.createObjectStore(SIGN_STORE);
    };
    req.onsuccess=()=>resolve(req.result);
    req.onerror=()=>reject(req.error);
  });
}
async function idbGet(key){
  const db=await openSignDb();
  return new Promise((resolve,reject)=>{
    const tx=db.transaction(SIGN_STORE,"readonly");
    const store=tx.objectStore(SIGN_STORE);
    const req=store.get(key);
    req.onsuccess=()=>resolve(req.result||null);
    req.onerror=()=>reject(req.error);
  });
}
async function idbSet(key, val){
  const db=await openSignDb();
  return new Promise((resolve,reject)=>{
    const tx=db.transaction(SIGN_STORE,"readwrite");
    const store=tx.objectStore(SIGN_STORE);
    const req=store.put(val, key);
    req.onsuccess=()=>resolve(true);
    req.onerror=()=>reject(req.error);
  });
}
async function idbDel(key){
  const db=await openSignDb();
  return new Promise((resolve,reject)=>{
    const tx=db.transaction(SIGN_STORE,"readwrite");
    const store=tx.objectStore(SIGN_STORE);
    const req=store.delete(key);
    req.onsuccess=()=>resolve(true);
    req.onerror=()=>reject(req.error);
  });
}

/* ===================== Asymmetric signing (ECDSA P-256) ===================== */
async function getOrCreateSigningKeyPair(){
  let kp = await idbGet(SIGN_KEYPAIR_ID);
  if(kp && kp.privateKey && kp.publicKey) return kp;
  kp = await crypto.subtle.generateKey(
    { name:"ECDSA", namedCurve:"P-256" },
    false,
    ["sign","verify"]
  );
  await idbSet(SIGN_KEYPAIR_ID, kp);
  return kp;
}
async function exportPublicJwk(){
  const kp=await getOrCreateSigningKeyPair();
  return crypto.subtle.exportKey("jwk", kp.publicKey);
}
async function computeKeyIdFromJwk(jwk){
  return sha256Hex(stableStringify(jwk));
}
async function signLedgerHashAsym(ledgerHash){
  const kp=await getOrCreateSigningKeyPair();
  const msg = enc.encode("MWAL_WALLET_LEDGER_V5|" + ledgerHash);
  const sig = await crypto.subtle.sign({ name:"ECDSA", hash:"SHA-256" }, kp.privateKey, msg);
  return b64FromArrayBuffer(sig);
}
async function verifyLedgerHashAsym(ledgerHash, sigB64, pubJwk){
  try{
    const pubKey = await crypto.subtle.importKey(
      "jwk", pubJwk, { name:"ECDSA", namedCurve:"P-256" }, true, ["verify"]
    );
    const msg = enc.encode("MWAL_WALLET_LEDGER_V5|" + ledgerHash);
    const sigBuf = arrayBufferFromB64(sigB64);
    return crypto.subtle.verify({ name:"ECDSA", hash:"SHA-256" }, pubKey, sigBuf, msg);
  }catch{ return false; }
}

/* ===================== MWAL Key parsing & proof validation ===================== */
function parseKey(key){
  const out={};
  const parts=String(key||"").trim().split("|");
  if(parts[0]!=="MWAL") return null;
  for(const p of parts.slice(1)){
    const i=p.indexOf("=");
    if(i<0) continue;
    out[p.slice(0,i)] = p.slice(i+1);
  }
  if(!out.TX || !out.TO || !out.AMOUNT) return null;
  out.FROM = out.FROM ? decodeURIComponent(out.FROM) : "‚Äî";
  out.LABEL = out.LABEL ? decodeURIComponent(out.LABEL) : "";
  out.TS = out.TS ? decodeURIComponent(out.TS) : "";
  return out;
}
async function validateProof(proof, expected){
  if(!proof || typeof proof!=="object") return {ok:false,err:"JSON invalide"};
  if(proof.protocol!==PROOF_PROTOCOL) return {ok:false,err:"BAD_PROTOCOL"};
  if(proof.txId!==expected.txId) return {ok:false,err:"TX mismatch"};
  if(proof.to!==expected.to) return {ok:false,err:"TO mismatch"};
  if(!proof.rules || proof.rules.unitMWAL!==UNIT_MWAL_STR || proof.rules.intervalMs!==INTERVAL_MS) return {ok:false,err:"Rules mismatch"};
  const blocks=Array.isArray(proof.blocks)?proof.blocks:[];
  if(blocks.length===0) return {ok:false,err:"No blocks"};

  let prev="GENESIS";
  for(let i=0;i<blocks.length;i++){
    const b=blocks[i];
    if(String(b.amountMWAL)!==UNIT_MWAL_STR) return {ok:false,err:"Bad unit"};
    if(b.prevHash!==prev) return {ok:false,err:"Chain broken"};
    if(i>0){
      const t0=Date.parse(blocks[i-1].timestamp);
      const t1=Date.parse(b.timestamp);
      if(!Number.isFinite(t0)||!Number.isFinite(t1)) return {ok:false,err:"Bad timestamp"};
      if((t1-t0)!==INTERVAL_MS) return {ok:false,err:"Interval != 4s"};
    }
    const copy=Object.assign({},b); delete copy.hash;
    const h=await sha256Hex(JSON.stringify(copy));
    if(h!==b.hash) return {ok:false,err:"Bad hash"};
    prev=b.hash;
  }
  if(proof.finalHash && proof.finalHash!==prev) return {ok:false,err:"Final hash mismatch"};
  const provedAmount=round8(blocks.length*UNIT_MWAL);
  const expAmount=Number(expected.amountMWAL);
  if(Math.abs(provedAmount-expAmount)>1e-8) return {ok:false,err:"Amount mismatch"};
  return {ok:true, provedAmount};
}

/* ===================== State ===================== */
const defaultState=() => ({
  addr:getOrCreateAddr(),
  balance:0,
  accepted:[],
  consumedTx:{},
  lastCheck:null,
  mining:null,
  lastOutgoing:null
});
let S=null;
function load(){
  try{
    const raw=localStorage.getItem(STORE_KEY);
    if(!raw){ S=defaultState(); save(); return; }
    S=Object.assign(defaultState(), JSON.parse(raw));
    S.addr=getOrCreateAddr();
    save();
  }catch{
    S=defaultState(); save();
  }
}
function save(){ localStorage.setItem(STORE_KEY, JSON.stringify(S)); }

/* ===================== Render ===================== */
function renderHeader(){
  $("addrLbl").textContent=S.addr;
  $("addr2Lbl").textContent=S.addr;
}
function renderStats(){
  $("balLbl").textContent=round8(S.balance).toFixed(8);
  $("rxCountLbl").textContent=String(S.accepted.length);
}
function renderHist(){
  const box=$("hist"); box.innerHTML="";
  if(!S.accepted.length){ box.innerHTML='<div class="small">Aucune r√©ception.</div>'; return; }
  const view=S.accepted.slice().reverse().slice(0,60);
  for(const tx of view){
    const div=document.createElement("div");
    div.className="item mono";
    div.innerHTML=`<b>${tx.txId}</b><br/>from: ${tx.from}<br/>amount: ${Number(tx.amountMWAL).toFixed(8)} MWAL<br/><span class="small">proofHash: ${String(tx.proofHash||"").slice(0,18)}‚Ä¶ ‚Ä¢ ${tx.ts}</span>`;
    box.appendChild(div);
  }
}

/* ===================== R√©ception ===================== */
function clearInputs(){
  $("inKey").value=""; $("inCode").value=""; $("inProof").value="";
  $("btnAccept").disabled=true;
  S.lastCheck=null; save();
  setStatus($("inStatus"),"Pr√™t.","");
}
async function check(){
  try{
    const keyRaw=$("inKey").value.trim();
    const codeRaw=$("inCode").value.trim();
    const proofRaw=$("inProof").value.trim();
    if(!keyRaw||!codeRaw||!proofRaw){ setStatus($("inStatus"),"‚ùå Il faut : cl√© + code + JSON.","err"); return; }

    const k=parseKey(keyRaw);
    if(!k){ setStatus($("inStatus"),"‚ùå Cl√© MWAL invalide.","err"); return; }
    if(k.TO!==S.addr){ setStatus($("inStatus"),`‚ùå TO ‚â† ton wallet (${S.addr}).`,"err"); return; }
    if(S.consumedTx[k.TX]){ setStatus($("inStatus"),"‚ùå TX d√©j√† re√ßue (replay).","err"); return; }

    let proof;
    try{ proof=JSON.parse(proofRaw); }catch{ setStatus($("inStatus"),"‚ùå JSON blocs invalide.","err"); return; }

    const vProof=await validateProof(proof,{txId:k.TX,to:k.TO,amountMWAL:k.AMOUNT,from:k.FROM});
    if(!vProof.ok){ setStatus($("inStatus"),"‚ùå Preuve invalide : "+vProof.err,"err"); return; }

    const secret=$("secret").value.trim()||"MWAL_CORE_2025_V2_PROTOCOL";
    let payload;
    try{ payload=await decryptJson(secret,codeRaw); }catch{ setStatus($("inStatus"),"‚ùå Code chiffr√© illisible (secret ?).","err"); return; }

    if(payload.protocol!==TX_PAYLOAD_PROTOCOL){ setStatus($("inStatus"),"‚ùå Mauvais protocole payload.","err"); return; }
    if(payload.txId!==k.TX || payload.to!==k.TO){ setStatus($("inStatus"),"‚ùå Incoh√©rence code ‚Üî cl√©.","err"); return; }
    if(String(payload.amountMWAL)!==String(k.AMOUNT)){ setStatus($("inStatus"),"‚ùå Montant code ‚Üî cl√© diff√©rent.","err"); return; }

    const proofHash=await sha256Hex(JSON.stringify(proof));
    if(payload.proofHash!==proofHash){ setStatus($("inStatus"),"‚ùå proofHash mismatch (code ‚Üî JSON).","err"); return; }

    S.lastCheck={ok:true,txId:k.TX,from:k.FROM,to:k.TO,amountMWAL:Number(k.AMOUNT),ts:k.TS||new Date().toISOString(),proofHash,key:keyRaw,code:codeRaw,proof};
    save();
    $("btnAccept").disabled=!instanceHasLock;
    setStatus($("inStatus"), instanceHasLock ? "‚úÖ V√©rification OK. Tu peux recevoir." : "üîí V√©rification OK, mais lecture seule (autre onglet actif).", instanceHasLock ? "ok" : "warn");
    log("‚úÖ CHECK OK tx="+k.TX+" amount="+k.AMOUNT);
  }catch(e){
    setStatus($("inStatus"),"‚ùå Erreur interne: "+(e&&e.message?e.message:String(e)),"err");
  }
}
function accept(){
  if(!instanceHasLock){
    setStatus($("inStatus"),"üîí Lecture seule : r√©ception bloqu√©e (autre onglet actif).","warn");
    return;
  }
  if(!S.lastCheck||!S.lastCheck.ok){ setStatus($("inStatus"),"‚ùå Rien √† recevoir.","err"); return; }
  const t=S.lastCheck;
  S.balance=round8(S.balance+Number(t.amountMWAL));
  S.accepted.push({txId:t.txId,from:t.from,to:t.to,amountMWAL:t.amountMWAL,ts:t.ts,proofHash:t.proofHash,codeOk:true});
  S.consumedTx[t.txId]=true;
  S.lastCheck=null;
  save();
  renderStats(); renderHist();
  $("btnAccept").disabled=true;
  setStatus($("inStatus"),"‚úÖ R√©ception enregistr√©e.","ok");
  log("üí∞ RECEIVED tx="+t.txId+" +"+t.amountMWAL.toFixed(8));
}

/* ===================== Envoi (minage) ===================== */
function computeTargetBlocks(amountMWAL){
  if(!(amountMWAL>0)) return 0;
  const exact=amountMWAL/UNIT_MWAL;
  const n=Math.round(exact);
  return (Math.abs(exact-n)<1e-9) ? n : 0;
}
function updateOutInfo(){
  const amt=Number($("outAmt").value||0);
  if(!amt){ $("outInfo").textContent="‚Äî"; return; }
  const n=computeTargetBlocks(amt);
  if(n<=0){
    const floorN=Math.floor(amt/UNIT_MWAL);
    const proved=floorN*UNIT_MWAL;
    const rem=amt-proved;
    $("outInfo").textContent=`‚ùå Non multiple exact. blocs possibles=${floorN} (= ${round8(proved).toFixed(8)}), reste=${round8(rem).toFixed(8)}`;
    return;
  }
  $("outInfo").textContent=`‚úÖ ${n} bloc(s) ‚Üí ~${n*4}s`;
}

let mineTimer=null;
function clearMineTimer(){ if(mineTimer){ clearTimeout(mineTimer); mineTimer=null; } }

async function makeBlock(prevHash,index,tsIso,txId){
  const block={index,timestamp:tsIso,walletId:S.addr,txId,amountMWAL:UNIT_MWAL_STR,prevHash,nonce:crypto.getRandomValues(new Uint32Array(1))[0]};
  block.hash=await sha256Hex(JSON.stringify(block));
  return block;
}
function updateMineUI(){
  const m=S.mining;
  const bar=$("mineBar"); const txt=$("mineTxt");
  if(!m){
    bar.style.width="0%"; txt.textContent="0 / 0";
    $("btnMinePause").disabled=true; $("btnMineResume").disabled=true; $("btnMineCancel").disabled=true;
    return;
  }
  const pct=m.targetBlocks?Math.min(100,(m.doneBlocks/m.targetBlocks)*100):0;
  bar.style.width=pct.toFixed(1)+"%";
  txt.textContent=`${m.doneBlocks} / ${m.targetBlocks}`;
  $("btnMinePause").disabled=(!instanceHasLock || m.status!=="RUNNING");
  $("btnMineResume").disabled=(!instanceHasLock || m.status!=="PAUSED");
  $("btnMineCancel").disabled=(!instanceHasLock || (m.status!=="RUNNING" && m.status!=="PAUSED"));
}
async function mineTick(){
  const m=S.mining;
  if(!m||m.status!=="RUNNING") return;
  const idx=m.doneBlocks;
  const prevHash=(idx===0)?"GENESIS":m.blocks[idx-1].hash;
  const canonTs=new Date(m.startTimeMs+idx*INTERVAL_MS).toISOString();
  const blk=await makeBlock(prevHash,idx,canonTs,m.txId);
  m.blocks.push(blk); m.doneBlocks+=1; save();
  updateMineUI();
  setStatus($("mineStatus"),`‚õèÔ∏è Minage bloc ${m.doneBlocks}/${m.targetBlocks}`,"ok");
  if(m.doneBlocks>=m.targetBlocks){
    m.status="DONE"; save(); clearMineTimer();
    await finalizeOutgoing();
    updateMineUI();
    setStatus($("mineStatus"),"‚úÖ Minage termin√©. Paquet pr√™t.","ok");
    log("‚úÖ MINE DONE tx="+m.txId);
    return;
  }
  clearMineTimer();
  mineTimer=setTimeout(()=>mineTick(),INTERVAL_MS);
}
function validateOutInputs(){
  const to=$("outTo").value.trim();
  const from=$("outFrom").value.trim()||"wallet";
  const label=$("outLabel").value.trim()||"";
  const amount=Number($("outAmt").value||0);
  if(!/^MWAL-(WALLET|POS)-[A-Z0-9]{6,12}$/.test(to)) return {ok:false,err:"Adresse TO invalide (MWAL-WALLET-... ou MWAL-POS-...)."};
  if(!(amount>0)) return {ok:false,err:"Montant invalide."};
  if(amount>S.balance+1e-12) return {ok:false,err:"Solde insuffisant."};
  const n=computeTargetBlocks(amount);
  if(n<=0) return {ok:false,err:"Montant non multiple exact de l‚Äôunit√©."};
  return {ok:true,to,from,label,amount,blocks:n};
}
async function mineStart(){
  if(!instanceHasLock){
    setStatus($("mineStatus"),"üîí Lecture seule : minage bloqu√© (autre onglet actif).","warn");
    return;
  }
  if(S.mining && (S.mining.status==="RUNNING"||S.mining.status==="PAUSED")){
    setStatus($("mineStatus"),"‚ö†Ô∏è Minage d√©j√† en cours.","warn");return;
  }
  const v=validateOutInputs();
  if(!v.ok){setStatus($("mineStatus"),"‚ùå "+v.err,"err");return;}

  $("outKey").value=""; $("outCode").value=""; $("outProof").value="";
  $("btnCopyOutKey").disabled=true; $("btnCopyOutCode").disabled=true; $("btnExportOutProof").disabled=true; $("btnCopyOutProof").disabled=true;

  const txId=uid("TX");
  S.mining={protocol:PROOF_PROTOCOL,txId,walletId:S.addr,rules:{unitMWAL:UNIT_MWAL_STR,intervalMs:INTERVAL_MS},
    to:v.to,from:v.from,label:v.label,amountMWAL:round8(v.amount),targetBlocks:v.blocks,doneBlocks:0,blocks:[],
    status:"RUNNING",createdAt:new Date().toISOString(),startTimeMs:Date.now()};
  S.lastOutgoing=null; save();
  updateMineUI();
  setStatus($("mineStatus"),`‚õèÔ∏è Minage d√©marr√© : ${v.blocks} blocs (~${v.blocks*4}s).`,"ok");
  log("‚õèÔ∏è MINE START tx="+txId+" to="+v.to+" amount="+v.amount.toFixed(8));
  clearMineTimer();
  mineTimer=setTimeout(()=>mineTick(),20);
}
function minePause(){ if(!instanceHasLock) return; if(!S.mining||S.mining.status!=="RUNNING")return; S.mining.status="PAUSED"; save(); clearMineTimer(); updateMineUI(); setStatus($("mineStatus"),"‚è∏ Pause.","warn"); }
function mineResume(){ if(!instanceHasLock) return; if(!S.mining||S.mining.status!=="PAUSED")return; S.mining.status="RUNNING"; save(); updateMineUI(); setStatus($("mineStatus"),"‚ñ∂ Reprise.","ok"); clearMineTimer(); mineTimer=setTimeout(()=>mineTick(),20); }
function mineCancel(){ if(!instanceHasLock) return; if(!S.mining||(S.mining.status!=="RUNNING"&&S.mining.status!=="PAUSED"))return; if(!confirm("Annuler le minage ?"))return; S.mining=null; save(); clearMineTimer(); updateMineUI(); setStatus($("mineStatus"),"‚úñ Annul√©.","warn"); }

async function finalizeOutgoing(){
  const m=S.mining;
  if(!m||m.status!=="DONE") return;
  const amountMWAL=round8(m.targetBlocks*UNIT_MWAL);
  const key=["MWAL","TX="+m.txId,"FROM="+encodeURIComponent(m.from),"TO="+m.to,"AMOUNT="+amountMWAL.toFixed(8),"TS="+encodeURIComponent(m.createdAt),
    m.label?("LABEL="+encodeURIComponent(m.label)):""].filter(Boolean).join("|");

  const proof={protocol:PROOF_PROTOCOL,walletId:m.walletId,txId:m.txId,rules:{unitMWAL:UNIT_MWAL_STR,intervalMs:INTERVAL_MS},to:m.to,from:m.from,label:m.label||"",
    createdAt:m.createdAt,blocks:m.blocks,finalHash:m.blocks.length?m.blocks[m.blocks.length-1].hash:"0"};

  const secret=$("secret").value.trim()||"MWAL_CORE_2025_V2_PROTOCOL";
  const proofHash=await sha256Hex(JSON.stringify(proof));
  const payload={protocol:TX_PAYLOAD_PROTOCOL,txId:m.txId,from:m.from,to:m.to,amountMWAL:amountMWAL.toFixed(8),createdAt:m.createdAt,label:m.label||"",proofHash};
  const code=await encryptJson(secret,payload);

  S.lastOutgoing={key,code,proof}; save();
  $("outKey").value=key; $("outCode").value=code; $("outProof").value=JSON.stringify(proof,null,2);
  $("btnCopyOutKey").disabled=false; $("btnCopyOutCode").disabled=false; $("btnExportOutProof").disabled=false; $("btnCopyOutProof").disabled=false;

  // d√©bit imm√©diat
  S.balance=round8(S.balance-amountMWAL); save();
  renderStats(); renderHist();
  setStatus($("sysStatus"),"‚úÖ Envoi pr√™t (d√©bit effectu√©). Transmets cl√©+code+JSON au receveur.","ok");
  log("‚û°Ô∏è SEND READY tx="+m.txId+" -"+amountMWAL.toFixed(8));
  S.mining=Object.assign({},m,{status:"ARCHIVED"}); save();
}

/* ===================== Download/copy ===================== */
function downloadJson(obj,filename){
  const json=JSON.stringify(obj,null,2);
  const blob=new Blob([json],{type:"application/json"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download=filename;
  a.click();
  URL.revokeObjectURL(a.href);
}
async function copyText(text){
  if(!text) return false;
  try{ await navigator.clipboard.writeText(text); return true; }catch{ return false; }
}

/* ===================== Ledger V5 (hash + signature asym) ===================== */
async function buildLedgerV5(){
  const pubJwk = await exportPublicJwk();
  const keyId = await computeKeyIdFromJwk(pubJwk);

  const base={
    protocol: LEDGER_PROTOCOL_V5,
    address: S.addr,
    balanceMWAL: round8(S.balance).toFixed(8),
    accepted: S.accepted,
    exportedAt: new Date().toISOString(),
    signer: { alg:"ECDSA_P256_SHA256", keyId, pubJwk }
  };

  const canonical = {
    protocol: base.protocol,
    address: base.address,
    balanceMWAL: base.balanceMWAL,
    accepted: base.accepted,
    exportedAt: base.exportedAt,
    signer: base.signer
  };

  const ledgerHash = await sha256Hex(stableStringify(canonical));
  const ledgerSigAsym = await signLedgerHashAsym(ledgerHash);

  return Object.assign({}, base, { ledgerHash, ledgerSigAsym });
}
async function exportLedger(){
  const data = await buildLedgerV5();
  downloadJson(data, `MWAL_WALLET_LEDGER_${S.addr}.json`);
  setStatus($("sysStatus"),"‚úÖ Ledger export√© (V5 sign√© ECDSA).","ok");
  log("üì¶ LEDGER EXPORT v5 addr="+S.addr+" keyId="+data.signer.keyId.slice(0,12));
}

/* ===================== Import ledger assistant ===================== */
let importedLedgerCtx=null;

function showLedgerModal(show){
  $("ledgerModalBackdrop").style.display = show ? "flex" : "none";
}
function modalSetStatus(msg,cls){ setStatus($("ledgerModalStatus"), msg, cls); }
function makePill(text, cls){
  const el=document.createElement("div");
  el.className="pilltag " + (cls||"");
  el.textContent=text;
  return el;
}
function summarizeLedgerKv(info){
  const kv=$("ledgerSummaryKv");
  kv.innerHTML="";
  const row=(k,v)=>{
    const kEl=document.createElement("div"); kEl.className="k"; kEl.textContent=k;
    const vEl=document.createElement("div"); vEl.className="v mono"; vEl.textContent=v;
    kv.appendChild(kEl); kv.appendChild(vEl);
  };
  row("Fichier", info.filename || "‚Äî");
  row("Protocol", info.protocol || "‚Äî");
  row("address", info.address || "‚Äî");
  row("balance", info.balanceMWAL || "‚Äî");
  row("accepted", String(info.txCount||0));
  row("exportedAt", info.exportedAt || "‚Äî");
  row("ledgerHash", info.ledgerHash ? (info.ledgerHash.slice(0,18)+"‚Ä¶") : "‚Äî");
  row("sig", info.sig ? (info.sig.slice(0,18)+"‚Ä¶") : "‚Äî");
  row("signerKeyId", info.signerKeyId ? (info.signerKeyId.slice(0,18)+"‚Ä¶") : "‚Äî");
}

async function parseAndVerifyLedger(rawObj){
  const protocol = rawObj && rawObj.protocol;
  if(protocol !== LEDGER_PROTOCOL_V3 && protocol !== LEDGER_PROTOCOL_V5){
    return { ok:false, err:"Protocole ledger non support√© (V3/V5)." };
  }
  if(!rawObj.address || !/^MWAL-WALLET-[A-Z0-9]{6,12}$/.test(rawObj.address)){
    return { ok:false, err:"Adresse invalide dans le ledger." };
  }
  if(!Array.isArray(rawObj.accepted)) return { ok:false, err:"Champ accepted invalide." };

  const accepted = rawObj.accepted.map(t => ({
    txId: String(t.txId||""),
    from: String(t.from||"‚Äî"),
    to: String(t.to||rawObj.address||""),
    amountMWAL: safeNum(t.amountMWAL),
    ts: String(t.ts||""),
    proofHash: String(t.proofHash||""),
    codeOk: !!t.codeOk
  })).filter(t => t.txId);

  const normalized = {
    protocol,
    address: rawObj.address,
    balanceMWAL: String(rawObj.balanceMWAL ?? "0.00000000"),
    accepted,
    exportedAt: String(rawObj.exportedAt||""),
    signer: rawObj.signer || null,
    ledgerHash: rawObj.ledgerHash ? String(rawObj.ledgerHash) : "",
    ledgerSigAsym: rawObj.ledgerSigAsym ? String(rawObj.ledgerSigAsym) : ""
  };

  let computedHash="", hashOk=null, sigAsymOk=null;

  if(protocol === LEDGER_PROTOCOL_V5){
    const canonical = {
      protocol: normalized.protocol,
      address: normalized.address,
      balanceMWAL: normalized.balanceMWAL,
      accepted: normalized.accepted,
      exportedAt: normalized.exportedAt,
      signer: normalized.signer
    };
    computedHash = await sha256Hex(stableStringify(canonical));
    hashOk = (normalized.ledgerHash && normalized.ledgerHash === computedHash);

    const pubJwk = normalized.signer && normalized.signer.pubJwk;
    if(pubJwk && normalized.ledgerSigAsym && normalized.ledgerHash){
      sigAsymOk = await verifyLedgerHashAsym(normalized.ledgerHash, normalized.ledgerSigAsym, pubJwk);
    }else{
      sigAsymOk = false;
    }
  }

  return { ok:true, normalized, verify:{ computedHash, hashOk, sigAsymOk } };
}

function getSelectedLedgerMode(){
  const radios = document.querySelectorAll('input[name="ledgerMode"]');
  for(const r of radios) if(r.checked) return r.value;
  return "restore";
}
function applyLedgerRestore(ledger){
  const consumedTx = {};
  for(const tx of ledger.accepted) consumedTx[tx.txId]=true;

  const nextState = {
    addr: ledger.address,
    balance: safeNum(ledger.balanceMWAL),
    accepted: ledger.accepted,
    consumedTx,
    lastCheck: null,
    mining: null,
    lastOutgoing: null
  };

  localStorage.setItem(STORE_KEY, JSON.stringify(nextState));
  localStorage.setItem(WALLET_ADDR_KEY, ledger.address);
}
function applyLedgerMerge(ledger){
  const existingConsumed = S.consumedTx || {};
  const added = [];
  for(const tx of ledger.accepted){
    if(!existingConsumed[tx.txId]) added.push(tx);
  }
  if(!added.length) return { addedCount:0, addedAmount:0 };
  const addAmount = round8(added.reduce((acc,t)=>acc + safeNum(t.amountMWAL),0));
  S.balance = round8(S.balance + addAmount);
  for(const tx of added){
    S.accepted.push(tx);
    S.consumedTx[tx.txId]=true;
  }
  save();
  return { addedCount: added.length, addedAmount: addAmount };
}

function openLedgerAssistant(file, obj, parsed){
  importedLedgerCtx = { file, obj, parsed };
  const ledger = parsed.normalized;
  const ver = parsed.verify;

  summarizeLedgerKv({
    filename: file ? file.name : "‚Äî",
    protocol: ledger.protocol,
    address: ledger.address,
    balanceMWAL: ledger.balanceMWAL,
    txCount: ledger.accepted.length,
    exportedAt: ledger.exportedAt || "‚Äî",
    ledgerHash: ledger.ledgerHash || "",
    sig: ledger.ledgerSigAsym || "",
    signerKeyId: ledger.signer && ledger.signer.keyId ? ledger.signer.keyId : ""
  });

  const pills = $("ledgerPills");
  pills.innerHTML="";

  if(ledger.protocol === LEDGER_PROTOCOL_V5){
    pills.appendChild(makePill("Ledger V5", "ok"));
    pills.appendChild(makePill(ver.hashOk ? "Hash OK" : "Hash mismatch", ver.hashOk ? "ok":"err"));
    pills.appendChild(makePill(ver.sigAsymOk ? "Signature ECDSA OK" : "Signature ECDSA invalide", ver.sigAsymOk ? "ok":"err"));

    const localKeyId = $("sigKeyId").value || "";
    const ledgerKeyId = ledger.signer && ledger.signer.keyId ? ledger.signer.keyId : "";
    if(localKeyId && ledgerKeyId){
      if(localKeyId === ledgerKeyId) pills.appendChild(makePill("Sign√© par CE wallet", "ok"));
      else pills.appendChild(makePill("Sign√© par un autre wallet", "warn"));
    }

    if(LEDGER_SAFE_MODE) pills.appendChild(makePill("Coffre-fort ON", "ok"));
  }else{
    pills.appendChild(makePill("Ledger V3 (ancien)", "warn"));
    pills.appendChild(makePill("Pas de signature ECDSA", "warn"));
  }

  if(!instanceHasLock){
    pills.appendChild(makePill("Lecture seule (autre onglet actif)", "warn"));
  }

  $("ledgerPreview").textContent = JSON.stringify(obj, null, 2).slice(0, 50000);
  document.querySelector('input[name="ledgerMode"][value="restore"]').checked = true;

  modalSetStatus("Pr√™t. Choisis un mode puis ‚ÄúAppliquer‚Äù.", "");
  showLedgerModal(true);

  enforceInstanceLockUI();
}

function importLedgerFile(file){
  const r=new FileReader();
  r.onload = async () => {
    try{
      const txt = String(r.result||"").trim();
      const obj = JSON.parse(txt);
      modalSetStatus("‚è≥ Analyse du ledger‚Ä¶","warn");

      const parsed = await parseAndVerifyLedger(obj);
      if(!parsed.ok){
        alert("‚ùå Ledger invalide :\n" + parsed.err);
        return;
      }
      openLedgerAssistant(file, obj, parsed);
      log("üì• LEDGER LOADED file="+file.name);
    }catch(e){
      alert("‚ùå Import ledger impossible :\n" + (e&&e.message?e.message:String(e)));
    }
  };
  r.readAsText(file);
}

/* ===================== Reset ===================== */
function resetAll(){
  if(!instanceHasLock){
    setStatus($("sysStatus"),"üîí Lecture seule : reset bloqu√© (autre onglet actif).","warn");
    return;
  }
  if(!confirm("Reset wallet ?")) return;
  localStorage.removeItem(STORE_KEY);
  localStorage.removeItem(WALLET_ADDR_KEY);
  location.reload();
}

/* ===================== Wire UI ===================== */
function wire(){
  $("btnCopyAddr").addEventListener("click",async()=>{
    const ok=await copyText(S.addr);
    setStatus($("sysStatus"), ok?"‚úÖ Adresse copi√©e.":"‚ùå Copie impossible.", ok?"ok":"err");
  });

  $("importProof").addEventListener("change",(e)=>{
    const file=e.target.files&&e.target.files[0];
    if(!file) return;
    const r=new FileReader();
    r.onload=()=>{
      try{
        const txt=String(r.result||"").trim();
        JSON.parse(txt);
        $("inProof").value=txt;
        setStatus($("inStatus"),"‚úÖ JSON import√©. Clique ‚ÄúV√©rifier‚Äù.","ok");
      }catch{ setStatus($("inStatus"),"‚ùå JSON invalide.","err"); }
    };
    r.readAsText(file);
  });

  $("btnCheck").addEventListener("click",check);
  $("btnAccept").addEventListener("click",accept);
  $("btnClear").addEventListener("click",clearInputs);

  $("outAmt").addEventListener("input",updateOutInfo);

  $("btnMineStart").addEventListener("click",mineStart);
  $("btnMinePause").addEventListener("click",minePause);
  $("btnMineResume").addEventListener("click",mineResume);
  $("btnMineCancel").addEventListener("click",mineCancel);

  $("btnCopyOutKey").addEventListener("click",async()=>{
    const ok=await copyText($("outKey").value);
    setStatus($("mineStatus"), ok?"‚úÖ Cl√© copi√©e.":"‚ùå Copie impossible.", ok?"ok":"err");
  });
  $("btnCopyOutCode").addEventListener("click",async()=>{
    const ok=await copyText($("outCode").value);
    setStatus($("mineStatus"), ok?"‚úÖ Code copi√©.":"‚ùå Copie impossible.", ok?"ok":"err");
  });
  $("btnCopyOutProof").addEventListener("click",async()=>{
    const ok=await copyText($("outProof").value);
    setStatus($("mineStatus"), ok?"‚úÖ JSON copi√©.":"‚ùå Copie impossible.", ok?"ok":"err");
  });
  $("btnExportOutProof").addEventListener("click",()=>{
    if(!S.lastOutgoing||!S.lastOutgoing.proof){ setStatus($("mineStatus"),"‚ùå Rien √† exporter.","err"); return; }
    downloadJson(S.lastOutgoing.proof,`MWAL_WALLET_PROOF_${S.addr}_${S.lastOutgoing.proof.txId}.json`);
  });

  // Ledger export/import
  $("btnExportLedger").addEventListener("click",()=>{ exportLedger().catch(e=>alert("‚ùå Export ledger: "+(e&&e.message?e.message:e))); });
  $("btnImportLedger").addEventListener("click",()=>{
    $("importLedger").value="";
    $("importLedger").click();
  });
  $("importLedger").addEventListener("change",(e)=>{
    const file=e.target.files&&e.target.files[0];
    if(file) importLedgerFile(file);
  });

  // Modal
  $("btnCloseLedgerModal").addEventListener("click",()=>showLedgerModal(false));
  $("btnLedgerCancel").addEventListener("click",()=>showLedgerModal(false));

  $("btnLedgerApply").addEventListener("click", async ()=>{
    try{
      if(!instanceHasLock){
        modalSetStatus("üîí Lecture seule : appliquer est bloqu√© (autre onglet actif).","warn");
        return;
      }
      if(!importedLedgerCtx || !importedLedgerCtx.parsed || !importedLedgerCtx.parsed.normalized){
        modalSetStatus("‚ùå Aucun ledger charg√©.","err");
        return;
      }
      const mode=getSelectedLedgerMode();
      const ledger=importedLedgerCtx.parsed.normalized;
      const ver=importedLedgerCtx.parsed.verify;

      if(ledger.protocol===LEDGER_PROTOCOL_V5){
        if(ver.hashOk !== true){
          modalSetStatus("‚ùå Hash du ledger invalide.","err");
          return;
        }
        if(ver.sigAsymOk !== true){
          modalSetStatus("‚ùå Signature ECDSA invalide : import bloqu√©.","err");
          return;
        }
        if(LEDGER_SAFE_MODE && mode!=="readonly"){
          const localKeyId = $("sigKeyId").value;
          const ledgerKeyId = ledger.signer && ledger.signer.keyId;
          if(!ledgerKeyId || ledgerKeyId !== localKeyId){
            modalSetStatus(
              "üîê Mode coffre-fort actif :\n" +
              "ce ledger n‚Äôa PAS √©t√© sign√© par ce wallet.\n" +
              "Restauration et fusion interdites.",
              "err"
            );
            return;
          }
        }
      }else{
        if(mode!=="readonly"){
          modalSetStatus("‚ö†Ô∏è Ledger ancien (V3) : pas de signature ECDSA.","warn");
          if(!confirm("Ledger V3 : continuer quand m√™me ?")) return;
        }
      }

      if(mode==="readonly"){
        modalSetStatus("üëÅÔ∏è Lecture seule : aucun changement appliqu√©.","ok");
        log("üëÅÔ∏è LEDGER READONLY addr="+ledger.address+" tx="+ledger.accepted.length);
        return;
      }

      if(mode==="restore"){
        if(!confirm("Restaurer va √âCRASER le wallet local. Continuer ?")) return;
        applyLedgerRestore(ledger);
        modalSetStatus("‚úÖ Restaur√©. Red√©marrage‚Ä¶","ok");
        log("‚úÖ LEDGER RESTORE addr="+ledger.address);
        setTimeout(()=>location.reload(), 200);
        return;
      }

      if(mode==="merge"){
        const res = applyLedgerMerge(ledger);
        renderHeader(); renderStats(); renderHist();
        modalSetStatus(`‚úÖ Fusion OK : +${res.addedCount} TX ( +${res.addedAmount.toFixed(8)} MWAL )`,"ok");
        log(`üß† LEDGER MERGE +${res.addedCount} +${res.addedAmount.toFixed(8)}MWAL fromLedgerAddr=${ledger.address}`);
        return;
      }

    }catch(e){
      modalSetStatus("‚ùå Erreur: "+(e&&e.message?e.message:String(e)),"err");
    }
  });

  $("btnResetAll").addEventListener("click",resetAll);

  // Signing identity UI
  $("btnExportPubKey").addEventListener("click", async ()=>{
    try{
      const jwk = await exportPublicJwk();
      const keyId = await computeKeyIdFromJwk(jwk);
      downloadJson({protocol:"MWAL_PUBKEY_V1", alg:"ECDSA_P256_SHA256", keyId, pubJwk:jwk, exportedAt:new Date().toISOString()}, `MWAL_PUBKEY_${keyId.slice(0,12)}.json`);
      setStatus($("sysStatus"),"‚úÖ Cl√© publique export√©e.","ok");
      log("üîì PUBKEY EXPORT keyId="+keyId.slice(0,12));
    }catch(e){
      setStatus($("sysStatus"),"‚ùå Export pubkey : "+(e&&e.message?e.message:String(e)),"err");
    }
  });

  $("btnRotateKeys").addEventListener("click", async ()=>{
    if(!instanceHasLock){
      setStatus($("sysStatus"),"üîí Lecture seule : rotation bloqu√©e (autre onglet actif).","warn");
      return;
    }
    if(!confirm("Rotation cl√©s = tu casses la continuit√© de signature. Continuer ?")) return;
    if(!confirm("Dernier avertissement : anciens ledgers V5 ne seront plus restaurables en coffre-fort. Continuer ?")) return;
    await idbDel(SIGN_KEYPAIR_ID);
    const kp = await getOrCreateSigningKeyPair();
    const jwk = await crypto.subtle.exportKey("jwk", kp.publicKey);
    const keyId = await computeKeyIdFromJwk(jwk);
    $("sigKeyId").value = keyId;
    setStatus($("sysStatus"),"‚ö†Ô∏è Rotation effectu√©e (nouvelle identit√©).","warn");
    log("üîÅ KEY ROTATE newKeyId="+keyId.slice(0,12));
  });
}

/* ===================== Init signature identity ===================== */
async function initSigningIdentity(){
  const kp = await getOrCreateSigningKeyPair();
  const jwk = await crypto.subtle.exportKey("jwk", kp.publicKey);
  const keyId = await computeKeyIdFromJwk(jwk);
  $("sigKeyId").value = keyId;
  log("üîê SIGN ID ready keyId="+keyId.slice(0,12));
}

/* ===================== Init ===================== */
load();
renderHeader();
renderStats();
renderHist();
wire();
updateOutInfo();

/* ===== Acquire lock AFTER UI is ready ===== */
instanceHasLock = acquireInstanceLock();
if(instanceHasLock){
  startInstanceHeartbeat();
  log("üîí Instance lock ACQUIS id="+INSTANCE_ID);
}else{
  log("üö´ Instance lock REFUS√â (autre onglet actif)");
  startReclaimLoop();
}
enforceInstanceLockUI();

/* ===== React to other tabs ===== */
window.addEventListener("storage", (e)=>{
  if(e.key !== INSTANCE_LOCK_KEY) return;
  const now = Date.now();
  const lock = _readLock();
  if(lock && lock.id !== INSTANCE_ID && (now - lock.ts) < INSTANCE_LOCK_TTL){
    if(instanceHasLock){
      instanceHasLock = false;
      stopInstanceHeartbeat();
      log("üö´ Instance lock PERDU (autre onglet actif)");
      enforceInstanceLockUI();
    }
  }else{
    const ok = acquireInstanceLock();
    if(ok && !instanceHasLock){
      instanceHasLock = true;
      startInstanceHeartbeat();
      log("üîí Instance lock ACQUIS (storage) id="+INSTANCE_ID);
      enforceInstanceLockUI();
    }
  }
});

/* ===== Release on exit ===== */
window.addEventListener("beforeunload", ()=>{
  releaseInstanceLock();
  stopInstanceHeartbeat();
});

/* ===== Init signature ===== */
initSigningIdentity().then(()=>{
  if(instanceHasLock){
    setStatus($("sysStatus"),"‚úÖ Wallet pr√™t. (Coffre-fort ON + verrou anti-onglets ON)","ok");
  }else{
    setStatus($("sysStatus"),
      "üîí Une autre instance du wallet est active.\nCette instance est en lecture seule (anti-duplication d‚Äôonglets).",
      "warn"
    );
  }
  log("‚úÖ Wallet OFFLINE charg√© addr="+S.addr);
}).catch(e=>{
  setStatus($("sysStatus"),"‚ùå Signature init : "+(e&&e.message?e.message:String(e)),"err");
  log("‚ùå SIGN INIT failed");
});
})();
</script>
</body>
</html>
